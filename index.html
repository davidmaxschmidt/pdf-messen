<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>PDF MaÃŸband â€“ EBG</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,300;9..40,500;9..40,700&display=swap" rel="stylesheet">
  <style>
    :root {
      --yellow: #FFF200; --black: #1a1a1a; --bg: #F5F5F5;
      --card: #FFFFFF; --text: #323130; --text2: #646464;
      --border: #E8E6E4; --border-l: #F3F2F1; --ftr: #969696;
      --hdr-h: 52px; --ftr-h: 36px;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; }
    body {
      font-family: 'DM Sans', -apple-system, system-ui, sans-serif;
      background: var(--bg); color: var(--text);
      display: flex; flex-direction: column; height: 100vh;
    }
    .hdr {
      background: var(--black); height: var(--hdr-h);
      display: flex; align-items: center; padding: 0 16px; gap: 12px;
      flex-shrink: 0; z-index: 100;
    }
    .hdr-logo { height: 28px; width: auto; }
    .hdr-sep { width: 2px; height: 22px; background: var(--yellow); border-radius: 1px; flex-shrink: 0; }
    .hdr h1 { color: #fff; font-size: 14px; font-weight: 500; white-space: nowrap; }
    .hdr h1 b { color: var(--yellow); font-weight: 700; }
    .hdr-spacer { flex: 1; }
    .hdr-toggle {
      background: none; border: 1.5px solid rgba(255,255,255,.2); border-radius: 6px;
      color: #fff; padding: 5px 10px; font-family: inherit; font-size: 11px; font-weight: 600;
      cursor: pointer; transition: all .15s; display: flex; align-items: center; gap: 5px; white-space: nowrap;
    }
    .hdr-toggle:hover { border-color: var(--yellow); color: var(--yellow); }
    .hdr-toggle.active { background: var(--yellow); color: var(--black); border-color: var(--yellow); }
    .hdr-toggle svg { width: 14px; height: 14px; }

    /* Mode toggle */
    .mode-toggle {
      background: none; border: 1.5px solid rgba(255,255,255,.2); border-radius: 6px;
      color: #fff; padding: 5px 10px; font-family: inherit; font-size: 11px; font-weight: 600;
      cursor: pointer; transition: all .15s; display: flex; align-items: center; gap: 5px; white-space: nowrap;
    }
    .mode-toggle:hover { border-color: var(--yellow); color: var(--yellow); }
    .mode-toggle.active { background: var(--yellow); color: var(--black); border-color: var(--yellow); }
    .mode-toggle svg { width: 14px; height: 14px; }

    .toolbar {
      background: var(--card); border-bottom: 1px solid var(--border-l);
      padding: 10px 16px; flex-shrink: 0; z-index: 90;
      display: none; overflow-x: auto; overflow-y: hidden;
    }
    .toolbar.open { display: block; }
    .tb-row { display: flex; gap: 10px; align-items: end; flex-wrap: wrap; }
    .cf { display: flex; flex-direction: column; gap: 3px; }
    .cf label { font-size: 10px; font-weight: 600; color: var(--text2); text-transform: uppercase; letter-spacing: .06em; }
    .cf input, .cf select {
      font-family: inherit; font-size: 13px; padding: 7px 9px;
      border-radius: 6px; border: 1.5px solid var(--border-l);
      background: #FAFAFA; color: var(--text); outline: none;
      transition: border-color .15s, box-shadow .15s; min-width: 0;
    }
    .cf input:focus, .cf select:focus { border-color: var(--yellow); box-shadow: 0 0 0 2px rgba(255,242,0,.15); }
    .cf input[type="file"] { padding: 5px; cursor: pointer; max-width: 220px; }
    .cf input[type="file"]::file-selector-button {
      font-family: inherit; font-size: 11px; font-weight: 600;
      padding: 4px 10px; border: none; border-radius: 4px;
      background: var(--black); color: #fff; cursor: pointer; margin-right: 6px;
    }
    .csz { display: flex; align-items: center; gap: 4px; }
    .csz input { width: 65px; }
    .csz .x { color: var(--text2); font-size: 12px; font-weight: 700; }
    .btn {
      font-family: inherit; font-size: 11.5px; font-weight: 600;
      padding: 7px 14px; border-radius: 6px; border: none;
      cursor: pointer; transition: all .15s;
      display: inline-flex; align-items: center; gap: 4px; white-space: nowrap;
    }
    .btn:disabled { opacity: .3; cursor: not-allowed; }
    .btn-y { background: var(--yellow); color: var(--black); }
    .btn-y:not(:disabled):hover { background: #e6d900; }
    .btn-g { background: transparent; color: var(--text2); border: 1.5px solid var(--border); }
    .btn-g:not(:disabled):hover { border-color: #bbb; }

    .viewer-wrap {
      flex: 1; overflow: auto; position: relative; background: #E0E0E0;
      /* Allow native scroll/pinch zoom on the scrollable area */
    }
    .viewer-inner { position: relative; display: inline-block; min-width: 100%; min-height: 100%; }
    .viewer-inner.centered { display: flex; align-items: center; justify-content: center; }
    canvas { display: block; }
    #overlay {
      position: absolute; left: 0; top: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 10;
    }

    /* â”€â”€ CROSSHAIR POINTS â”€â”€ */
    .mpoint {
      position: absolute; z-index: 20;
      width: 22px; height: 22px;
      /* touch-action: none ONLY on the point, not the viewer */
      touch-action: none;
      user-select: none; -webkit-user-select: none;
    }
    /* Default state: not grabbable, just visual */
    .mpoint { pointer-events: none; }
    /* In measure mode: grabbable */
    body.measure-mode .mpoint { pointer-events: auto; cursor: grab; }
    body.measure-mode .mpoint:active { cursor: grabbing; }

    .mpoint-crosshair { width: 100%; height: 100%; position: relative; }
    .mpoint-disc {
      position: absolute; inset: 3px; border-radius: 50%;
      background: rgba(255, 242, 0, 0.2);
      border: 1.5px solid rgba(255, 242, 0, 0.65);
      box-shadow: 0 0 6px rgba(255, 242, 0, 0.2);
      transition: transform .1s, background .1s, box-shadow .1s;
    }
    body.measure-mode .mpoint:hover .mpoint-disc {
      background: rgba(255, 242, 0, 0.3);
      box-shadow: 0 0 10px rgba(255, 242, 0, 0.35);
    }
    .mpoint.dragging .mpoint-disc {
      background: rgba(255, 242, 0, 0.35);
      box-shadow: 0 0 16px rgba(255, 242, 0, 0.45);
    }
    .mpoint-h, .mpoint-v { position: absolute; background: rgba(255, 242, 0, 0.8); }
    .mpoint-h { width: 100%; height: 1px; top: 50%; left: 0; transform: translateY(-50%); }
    .mpoint-v { height: 100%; width: 1px; left: 50%; top: 0; transform: translateX(-50%); }
    .mpoint-hd, .mpoint-vd { position: absolute; background: rgba(0, 0, 0, 0.25); }
    .mpoint-hd { width: 100%; height: 0.5px; top: calc(50% + 1px); left: 0; }
    .mpoint-vd { height: 100%; width: 0.5px; left: calc(50% + 1px); top: 0; }
    .mpoint-center {
      position: absolute; width: 2px; height: 2px; border-radius: 50%;
      background: var(--yellow); box-shadow: 0 0 2px rgba(0,0,0,.4);
      top: 50%; left: 50%; transform: translate(-50%, -50%);
    }
    .mpoint-label {
      position: absolute;
      top: -14px; left: 50%; transform: translateX(-50%);
      font-size: 9px; font-weight: 700; color: var(--black);
      background: rgba(255, 242, 0, 0.85);
      padding: 0px 4px; border-radius: 2px;
      font-family: 'DM Sans', sans-serif;
      line-height: 1.4; white-space: nowrap; pointer-events: none;
    }

    .kpi-bar {
      position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
      z-index: 50; display: none;
      background: rgba(26,26,26,.92); backdrop-filter: blur(8px);
      border-radius: 10px; padding: 8px 14px;
      gap: 8px; align-items: center; flex-wrap: wrap; justify-content: center;
      box-shadow: 0 4px 20px rgba(0,0,0,.3); max-width: calc(100% - 20px);
    }
    .kpi-bar.show { display: flex; }
    .kp { color: #fff; font-size: 12px; font-weight: 500; display: flex; align-items: center; gap: 4px; white-space: nowrap; }
    .kp strong { color: var(--yellow); font-weight: 700; font-size: 14px; }
    .kp-sep { width: 1px; height: 18px; background: rgba(255,255,255,.15); flex-shrink: 0; }
    .status-float {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      z-index: 50; padding: 5px 14px;
      background: rgba(26,26,26,.85); backdrop-filter: blur(6px);
      border-radius: 8px; font-size: 11px; color: rgba(255,255,255,.7);
      max-width: calc(100% - 20px); text-align: center;
      pointer-events: none; transition: opacity .2s;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .status-float.ok { color: rgba(80,220,140,.9); }
    .status-float.warn { color: rgba(255,200,60,.9); }
    .status-float:empty { opacity: 0; }
    .empty-state {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      height: 100%; gap: 12px; color: var(--text2); opacity: .5;
    }
    .empty-state svg { width: 52px; height: 52px; }
    .empty-state p { font-size: 14px; }
    .ftr {
      background: var(--black); height: var(--ftr-h);
      display: flex; align-items: center; justify-content: center;
      font-size: 10.5px; color: var(--ftr); flex-shrink: 0;
    }

    /* Mode indicator border glow */
    body.measure-mode .viewer-wrap {
      box-shadow: inset 0 0 0 2px rgba(255,242,0,.4);
    }

    @media (max-width: 600px) {
      .hdr { padding: 0 10px; gap: 6px; }
      .hdr h1 { font-size: 12.5px; }
      .hdr-logo { height: 24px; }
      .toolbar { padding: 8px 10px; }
      .tb-row { gap: 8px; }
      .kpi-bar { padding: 6px 10px; bottom: 8px; }
      .kp { font-size: 11px; } .kp strong { font-size: 12px; }
      .tb-label { display: none; }
      .mode-label { display: none; }
    }
  </style>
</head>
<body>
  <header class="hdr">
    <img class="hdr-logo" src="logo.png" alt="EBG" onerror="this.style.display='none'">
    <div class="hdr-sep"></div>
    <h1>PDF <b>MaÃŸband</b></h1>
    <div class="hdr-spacer"></div>

    <!-- Mode toggle: switch between navigate (scroll/zoom) and measure (place/drag points) -->
    <button class="mode-toggle" id="modeToggle" title="Modus wechseln: Navigieren â†” Messen">
      <svg id="modeIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round">
        <circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/>
      </svg>
      <span class="mode-label" id="modeLabel">Messen</span>
    </button>

    <button class="hdr-toggle active" id="tbToggle">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"><circle cx="12" cy="12" r="3"/><path d="M12.22 2h-.44a2 2 0 00-2 2v.18a2 2 0 01-1 1.73l-.43.25a2 2 0 01-2 0l-.15-.08a2 2 0 00-2.73.73l-.22.38a2 2 0 00.73 2.73l.15.1a2 2 0 011 1.72v.51a2 2 0 01-1 1.74l-.15.09a2 2 0 00-.73 2.73l.22.38a2 2 0 002.73.73l.15-.08a2 2 0 012 0l.43.25a2 2 0 011 1.73V20a2 2 0 002 2h.44a2 2 0 002-2v-.18a2 2 0 011-1.73l.43-.25a2 2 0 012 0l.15.08a2 2 0 002.73-.73l.22-.39a2 2 0 00-.73-2.73l-.15-.08a2 2 0 01-1-1.74v-.5a2 2 0 011-1.74l.15-.09a2 2 0 00.73-2.73l-.22-.38a2 2 0 00-2.73-.73l-.15.08a2 2 0 01-2 0l-.43-.25a2 2 0 01-1-1.73V4a2 2 0 00-2-2z"/></svg>
      <span class="tb-label">Einstellungen</span>
    </button>
  </header>

  <div class="toolbar open" id="toolbar">
    <div class="tb-row">
      <div class="cf">
        <label>PDF</label>
        <input id="file" type="file" accept="application/pdf" />
      </div>
      <div class="cf">
        <label>Seite</label>
        <select id="pageSelect" disabled style="width:90px"></select>
      </div>
      <div class="cf">
        <label>Zoom</label>
        <select id="zoomSelect" disabled style="width:100px">
          <option value="fit">Anpassen</option>
          <option value="0.75">75 %</option>
          <option value="1">100 %</option>
          <option value="1.25">125 %</option>
          <option value="1.5">150 %</option>
          <option value="2">200 %</option>
          <option value="3">300 %</option>
          <option value="4">400 %</option>
        </select>
      </div>
      <div class="cf">
        <label>MaÃŸstab 1:</label>
        <input id="scaleN" type="number" min="1" step="1" value="250" style="width:80px" />
      </div>
      <div class="cf">
        <label>BlattgrÃ¶ÃŸe</label>
        <select id="paperPreset" style="width:130px">
          <option value="auto">Auto (PDF)</option>
          <option value="A4">A4</option>
          <option value="A3">A3</option>
          <option value="A2">A2</option>
          <option value="custom">Custom</option>
        </select>
      </div>
      <div class="cf">
        <label>Custom mm</label>
        <div class="csz">
          <input id="customW" type="number" min="10" step="1" value="210" />
          <span class="x">Ã—</span>
          <input id="customH" type="number" min="10" step="1" value="297" />
        </div>
      </div>
      <div class="cf" style="justify-content:end">
        <div style="display:flex;gap:6px">
          <button id="clear" class="btn btn-g" disabled>ZurÃ¼cksetzen</button>
          <button id="copy" class="btn btn-y" disabled>ðŸ“‹ Kopieren</button>
        </div>
      </div>
    </div>
  </div>

  <div class="viewer-wrap" id="viewerWrap">
    <div class="viewer-inner centered" id="viewerInner">
      <canvas id="pdfCanvas" style="display:none"></canvas>
    </div>
    <svg id="overlay"></svg>

    <div class="mpoint" id="ptA" style="display:none">
      <div class="mpoint-crosshair">
        <div class="mpoint-disc"></div>
        <div class="mpoint-h"></div><div class="mpoint-hd"></div>
        <div class="mpoint-v"></div><div class="mpoint-vd"></div>
        <div class="mpoint-center"></div>
        <div class="mpoint-label">A</div>
      </div>
    </div>
    <div class="mpoint" id="ptB" style="display:none">
      <div class="mpoint-crosshair">
        <div class="mpoint-disc"></div>
        <div class="mpoint-h"></div><div class="mpoint-hd"></div>
        <div class="mpoint-v"></div><div class="mpoint-vd"></div>
        <div class="mpoint-center"></div>
        <div class="mpoint-label">B</div>
      </div>
    </div>

    <div class="status-float" id="status"></div>
    <div class="kpi-bar" id="kpiBar"></div>
    <div class="empty-state" id="emptyState">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round">
        <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>
        <polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/>
      </svg>
      <p>PDF auswÃ¤hlen, um zu messen</p>
    </div>
  </div>

  <footer class="ftr">Â© 2026 David Schmidt</footer>

  <script type="module">
    import * as pdfjsLib from "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.4.149/pdf.mjs";
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.4.149/pdf.worker.mjs";

    const $ = id => document.getElementById(id);
    const fileInput = $("file"), pageSelect = $("pageSelect"), zoomSelect = $("zoomSelect"),
          scaleNInput = $("scaleN"), paperPreset = $("paperPreset"),
          customW = $("customW"), customH = $("customH"),
          clearBtn = $("clear"), copyBtn = $("copy"),
          statusEl = $("status"), kpiBar = $("kpiBar"),
          viewerWrap = $("viewerWrap"), viewerInner = $("viewerInner"),
          canvas = $("pdfCanvas"), ctx = canvas.getContext("2d", { alpha: false }),
          overlay = $("overlay"), emptyState = $("emptyState"),
          ptAEl = $("ptA"), ptBEl = $("ptB"),
          tbToggle = $("tbToggle"), toolbar = $("toolbar"),
          modeToggle = $("modeToggle"), modeLabel = $("modeLabel"), modeIcon = $("modeIcon");

    let pdfDoc = null, page = null, pageNum = 1;
    let userZoom = "fit", renderScale = 1, viewport = null;
    let ptA = null, ptB = null;

    // â”€â”€ MODE: "navigate" (default, scroll/zoom free) or "measure" (place/drag points) â”€â”€
    let mode = "navigate";

    function setMode(m) {
      mode = m;
      if (mode === "measure") {
        document.body.classList.add("measure-mode");
        modeToggle.classList.add("active");
        modeLabel.textContent = "Messen";
        modeIcon.innerHTML = '<circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/>';
        if (pdfDoc) setStatus("Messen-Modus: Tippe zum Setzen, ziehe zum Verschieben", "ok");
      } else {
        document.body.classList.remove("measure-mode");
        modeToggle.classList.remove("active");
        modeLabel.textContent = "Navigieren";
        modeIcon.innerHTML = '<polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/>';
        if (pdfDoc) setStatus("Navigieren: Scrollen & Zoomen frei Â· Wechsle zu Messen âŠ•", "ok");
      }
    }

    modeToggle.addEventListener("click", () => {
      setMode(mode === "navigate" ? "measure" : "navigate");
    });

    tbToggle.addEventListener("click", () => {
      toolbar.classList.toggle("open");
      tbToggle.classList.toggle("active");
      if (pdfDoc) setTimeout(() => render().catch(console.error), 50);
    });

    function setStatus(html, cls = "") {
      statusEl.className = "status-float " + cls;
      statusEl.innerHTML = html;
    }

    function resetMeasure() {
      ptA = null; ptB = null;
      overlay.innerHTML = "";
      kpiBar.innerHTML = ""; kpiBar.classList.remove("show");
      ptAEl.style.display = "none"; ptBEl.style.display = "none";
      copyBtn.disabled = true; clearBtn.disabled = true;
    }

    function mmPerPointFromPaper(wPt, hPt) {
      const MM = 25.4 / 72, p = paperPreset.value;
      if (p === "auto") return { mmPerPt: MM, note: "Auto Â· 1pt = " + MM.toFixed(4) + " mm", warn: false };
      let w, h;
      if (p === "A4") { w=210; h=297; } else if (p === "A3") { w=297; h=420; }
      else if (p === "A2") { w=420; h=594; }
      else { w = +customW.value || 0; h = +customH.value || 0; }
      if (!(w > 0 && h > 0)) return { mmPerPt: MM, note: "UngÃ¼ltig â†’ Auto", warn: true };
      const mmPt = ((w / wPt) + (h / hPt)) / 2;
      const mis = Math.abs((wPt/hPt) - (w/h)) / (w/h);
      return { mmPerPt: mmPt, note: `${p}: ${w}Ã—${h} mm`, warn: mis > 0.03 };
    }

    function cssToPt(clientX, clientY) {
      const r = canvas.getBoundingClientRect(), dpr = devicePixelRatio || 1;
      const cx = (clientX - r.left) * (canvas.width / r.width);
      const cy = (clientY - r.top) * (canvas.height / r.height);
      return { xPt: cx / (renderScale * dpr), yPt: cy / (renderScale * dpr) };
    }

    function ptToCss(xPt, yPt) {
      const r = canvas.getBoundingClientRect(), wr = viewerWrap.getBoundingClientRect();
      const dpr = devicePixelRatio || 1;
      return {
        x: (xPt * renderScale * dpr * (r.width / canvas.width)) + (r.left - wr.left) + viewerWrap.scrollLeft,
        y: (yPt * renderScale * dpr * (r.height / canvas.height)) + (r.top - wr.top) + viewerWrap.scrollTop,
      };
    }

    const CH_HALF = 11;
    function positionPoint(el, xPt, yPt) {
      const { x, y } = ptToCss(xPt, yPt);
      el.style.left = (x - CH_HALF) + "px";
      el.style.top = (y - CH_HALF) + "px";
    }

    function drawLine() {
      if (!ptA || !ptB) { overlay.innerHTML = ""; return; }
      const a = ptToCss(ptA.xPt, ptA.yPt), b = ptToCss(ptB.xPt, ptB.yPt);
      const sw = Math.max(viewerInner.scrollWidth, viewerWrap.clientWidth);
      const sh = Math.max(viewerInner.scrollHeight, viewerWrap.clientHeight);
      overlay.style.width = sw + "px"; overlay.style.height = sh + "px";
      overlay.setAttribute("viewBox", `0 0 ${sw} ${sh}`);
      overlay.innerHTML = `
        <line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}" stroke="#FFF200" stroke-width="2" stroke-dasharray="6 3" opacity=".75"/>
        <line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}" stroke="rgba(0,0,0,.3)" stroke-width="0.8" stroke-dasharray="6 3" stroke-dashoffset="3"/>
      `;
    }

    function updateKpis() {
      if (!page || !ptA || !ptB) return;
      const base = page.getViewport({ scale: 1 });
      const paper = mmPerPointFromPaper(base.width, base.height);
      const n = Math.max(1, +scaleNInput.value || 1);
      const mm = Math.hypot(ptB.xPt - ptA.xPt, ptB.yPt - ptA.yPt) * paper.mmPerPt;
      kpiBar.innerHTML = `
        <span class="kp"><strong>${mm.toFixed(1)}</strong>&thinsp;mm</span>
        <span class="kp-sep"></span>
        <span class="kp"><strong>${(mm/10).toFixed(2)}</strong>&thinsp;cm</span>
        <span class="kp-sep"></span>
        <span class="kp"><strong>${((mm/1000)*n).toFixed(3)}</strong>&thinsp;m&ensp;(1:${n})</span>
      `;
      kpiBar.classList.add("show");
      copyBtn.disabled = false;
    }

    function refreshOverlay() {
      if (ptA) positionPoint(ptAEl, ptA.xPt, ptA.yPt);
      if (ptB) positionPoint(ptBEl, ptB.xPt, ptB.yPt);
      drawLine(); updateKpis();
    }

    async function render() {
      if (!pdfDoc) return;
      page = await pdfDoc.getPage(pageNum);
      const base = page.getViewport({ scale: 1 });
      const wr = viewerWrap.getBoundingClientRect();
      const fitScale = Math.min(wr.width / base.width, wr.height / base.height);
      renderScale = userZoom === "fit" ? fitScale : (fitScale * +userZoom);
      viewport = page.getViewport({ scale: renderScale });
      const dpr = devicePixelRatio || 1;
      canvas.width = Math.floor(viewport.width * dpr);
      canvas.height = Math.floor(viewport.height * dpr);
      canvas.style.width = viewport.width + "px";
      canvas.style.height = viewport.height + "px";
      viewerInner.classList.toggle("centered", viewport.width <= wr.width && viewport.height <= wr.height);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = true;
      await page.render({ canvasContext: ctx, viewport }).promise;
      const paper = mmPerPointFromPaper(base.width, base.height);
      setStatus(`${paper.warn ? "âš " : "âœ“"} ${paper.note} Â· ${base.width.toFixed(0)}Ã—${base.height.toFixed(0)} pt`, paper.warn ? "warn" : "ok");
      refreshOverlay();
    }

    async function loadPdf(file) {
      resetMeasure(); setStatus("Ladenâ€¦");
      pdfDoc = await pdfjsLib.getDocument({ data: await file.arrayBuffer() }).promise;
      pageSelect.innerHTML = "";
      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const o = document.createElement("option");
        o.value = i; o.textContent = `${i} / ${pdfDoc.numPages}`;
        pageSelect.appendChild(o);
      }
      pageNum = 1; pageSelect.value = "1"; pageSelect.disabled = false;
      zoomSelect.value = "fit"; userZoom = "fit"; zoomSelect.disabled = false;
      canvas.style.display = "block"; emptyState.style.display = "none";
      viewerInner.classList.remove("centered");
      setMode("measure"); // start in measure mode after loading
      await render();
    }

    // â”€â”€ DRAG POINTS (only in measure mode) â”€â”€
    let dragging = null;
    const grabOffset = { x: 0, y: 0 };

    function startDrag(which, ev) {
      if (mode !== "measure") return;
      ev.preventDefault(); ev.stopPropagation();
      dragging = which;
      const el = which === 'A' ? ptAEl : ptBEl;
      const pt = which === 'A' ? ptA : ptB;
      el.classList.add("dragging");
      el.setPointerCapture(ev.pointerId);
      // Offset: keep crosshair center offset from pointer so finger doesn't cover it
      const pointerPt = cssToPt(ev.clientX, ev.clientY);
      grabOffset.x = pt.xPt - pointerPt.xPt;
      grabOffset.y = pt.yPt - pointerPt.yPt;
    }

    document.addEventListener("pointermove", ev => {
      if (!dragging || !page) return;
      const pointerPt = cssToPt(ev.clientX, ev.clientY);
      const newPt = { xPt: pointerPt.xPt + grabOffset.x, yPt: pointerPt.yPt + grabOffset.y };
      if (dragging === 'A') { ptA = newPt; positionPoint(ptAEl, newPt.xPt, newPt.yPt); }
      else { ptB = newPt; positionPoint(ptBEl, newPt.xPt, newPt.yPt); }
      drawLine(); updateKpis();
    });

    document.addEventListener("pointerup", () => {
      if (!dragging) return;
      (dragging === 'A' ? ptAEl : ptBEl).classList.remove("dragging");
      dragging = null;
    });

    ptAEl.addEventListener("pointerdown", ev => startDrag('A', ev));
    ptBEl.addEventListener("pointerdown", ev => startDrag('B', ev));

    // â”€â”€ CLICK TO PLACE (only in measure mode) â”€â”€
    viewerWrap.addEventListener("pointerdown", ev => {
      if (mode !== "measure") return; // navigate mode: let browser handle scroll/zoom
      if (!pdfDoc || !page || ev.target.closest(".mpoint")) return;

      const pt = cssToPt(ev.clientX, ev.clientY);
      if (!ptA) {
        ptA = pt; ptAEl.style.display = "block"; positionPoint(ptAEl, pt.xPt, pt.yPt);
        clearBtn.disabled = false;
        setStatus("Punkt A âœ“ â€“ tippe Punkt B", "ok"); return;
      }
      if (!ptB) {
        ptB = pt; ptBEl.style.display = "block"; positionPoint(ptBEl, pt.xPt, pt.yPt);
        drawLine(); updateKpis();
        setStatus("Punkte verschiebbar Â· Wechsle zu Navigieren zum Zoomen", "ok"); return;
      }
      // Both placed: move the closer one
      const dA = Math.hypot(pt.xPt - ptA.xPt, pt.yPt - ptA.yPt);
      const dB = Math.hypot(pt.xPt - ptB.xPt, pt.yPt - ptB.yPt);
      if (dA <= dB) { ptA = pt; positionPoint(ptAEl, pt.xPt, pt.yPt); }
      else { ptB = pt; positionPoint(ptBEl, pt.xPt, pt.yPt); }
      drawLine(); updateKpis();
    });

    // â”€â”€ Standard events â”€â”€
    fileInput.addEventListener("change", e => {
      const f = e.target.files?.[0];
      if (f) loadPdf(f).catch(err => { console.error(err); setStatus("Fehler â€“ HTTPS nutzen", "warn"); });
    });
    pageSelect.addEventListener("change", async () => { pageNum = +pageSelect.value; resetMeasure(); await render(); });
    zoomSelect.addEventListener("change", async () => { userZoom = zoomSelect.value; await render(); });
    paperPreset.addEventListener("change", () => { if (pdfDoc) render().catch(console.error); });
    customW.addEventListener("input", () => { if (paperPreset.value === "custom" && pdfDoc) render().catch(console.error); });
    customH.addEventListener("input", () => { if (paperPreset.value === "custom" && pdfDoc) render().catch(console.error); });
    scaleNInput.addEventListener("input", () => updateKpis());

    clearBtn.addEventListener("click", () => {
      resetMeasure();
      if (pdfDoc) setStatus("ZurÃ¼ckgesetzt â€“ tippe zwei neue Punkte", "ok");
    });

    copyBtn.addEventListener("click", async () => {
      if (!(ptA && ptB && page)) return;
      const base = page.getViewport({ scale: 1 });
      const paper = mmPerPointFromPaper(base.width, base.height);
      const n = Math.max(1, +scaleNInput.value || 1);
      const mm = Math.hypot(ptB.xPt - ptA.xPt, ptB.yPt - ptA.yPt) * paper.mmPerPt;
      const text = `PDF MaÃŸband\nSeite: ${pageNum}\nMaÃŸstab: 1:${n}\nPapier: ${mm.toFixed(1)} mm (${(mm/10).toFixed(2)} cm)\nReal: ${((mm/1000)*n).toFixed(3)} m`;
      try { await navigator.clipboard.writeText(text); setStatus("âœ“ Kopiert!", "ok"); }
      catch { prompt("Kopieren:", text); }
    });

    let rt;
    window.addEventListener("resize", () => { if (pdfDoc) { clearTimeout(rt); rt = setTimeout(() => render().catch(console.error), 120); } });
    viewerWrap.addEventListener("scroll", () => { if (ptA || ptB) refreshOverlay(); });

    // Start in navigate mode
    setMode("navigate");
  </script>
</body>
</html>
